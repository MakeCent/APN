import numpy as np
import torch


def uniform_1d_sampling(vector, num_sampling):
    input_type = type(vector)
    if isinstance(vector, (list, tuple, range)):
        vector = np.array(vector)
    idx = np.linspace(0, len(vector) - 1, num_sampling, dtype=int)
    if input_type == list:
        return vector[idx].tolist()
    else:
        return vector[idx]


def compute_iou(a, b):
    ov = 0
    union = max(a[1], b[1]) - min(a[0], b[0])
    intersection = min(a[1], b[1]) - max(a[0], b[0])
    if intersection > 0:
        ov = intersection / union
    return ov


def matrix_iou(gt, ads):
    ov_m = np.zeros([gt.shape[0], ads.shape[0]])
    for i in range(gt.shape[0]):
        for j in range(ads.shape[0]):
            ov_m[i, j] = compute_iou(gt[i, :], ads[j, :])
    return ov_m


def cluster_and_flatten(arr, gap):
    # cluster arr wit gap smaller than a value
    m = [[arr[0]]]
    for x in arr[1:]:
        if x - m[-1][0] < gap:
            m[-1].append(x)
        else:
            m.append([x])
    # fetch element from each cluster, have many choices while here we only keep first ele in each cluster.
    r = [c[0] for c in m]
    # r = []
    # for c in m:
    #     r.extend([c[0], c[len(c)//2], c[-1]])
    return r


def score_progression_proposal(proposal, method='mse'):
    template = np.linspace(0, 100, len(proposal))
    # xmin, xmax = (49, 51)
    # noise = (proposal > xmin) & (proposal < xmax)
    # template, proposal = template * ~noise, proposal * ~noise
    if method == 'mae':
        mse = np.abs(template - proposal).mean()
        score = -mse / 33.33 + 1
    elif method == 'mse':
        mse = ((template - proposal) ** 2).mean()
        score = -mse / 1666.66 + 1
    else:
        raise ValueError(f'cannot understand the scoring method {method}')
    return score


def apn_detection_on_single_video(progressions, rescale_rate=1.0, det_kwargs={}):
    # sampling = det_kwargs.get('sampling', 1000)  # experimental argument
    search_kwargs = det_kwargs.get('search', {})
    search_kwargs['min_L'] /= rescale_rate
    nms_kwargs = det_kwargs.get('nms', {})

    # assert sampling == 'full' or isinstance(sampling, int)
    # original_len = progressions.shape[0]
    # if sampling == 'full':
    #     sampling = original_len
    # rescale_rate = original_len / sampling

    dets_and_scores = []
    for class_ind, progs_by_class in enumerate(progressions.T):
        # p = imresize(p_by_v_by_c[np.newaxis, ...].astype(np.float), (rescale_len, 1)).squeeze()
        # progs_by_class = uniform_1d_sampling(progs_by_class, sampling) if sampling != original_len else progs_by_class
        dets_by_class, scores_by_class = apn_detection_on_vector(progs_by_class, **search_kwargs)
        dets_by_class = dets_by_class * rescale_rate
        dets_by_class, scores_by_class = nms1d(dets_by_class, scores_by_class, **nms_kwargs)
        dets_and_scores.append(np.hstack([dets_by_class, scores_by_class[:, None]]))

    search_kwargs['min_L'] *= rescale_rate
    return dets_and_scores


def apn_detection_on_vector(progression_vector, min_e=60, max_s=40, min_L=60, score_threshold=0, method='mse'):
    """

    :param progression_vector:
    :param min_e:
    :param max_s:
    :param min_L:
    :return:
    """
    progs = progression_vector.squeeze()
    start_candidates = np.where(progs < max_s)[0]
    # start_candidates = cluster_and_flatten(start_candidates, 2)
    end_candidates = np.where(progs > min_e)[0]
    # end_candidates = cluster_and_flatten(end_candidates, 2)
    dets = []
    scores = []

    for start in start_candidates:
        for end in end_candidates:
            this_action_length = end - start + 1
            if this_action_length > min_L:
                score = score_progression_proposal(progs[start:end+1], method)
                if score > score_threshold:
                    dets.append([start, end])
                    scores.append(score)

    dets = np.array(dets)
    scores = np.array(scores)
    descending = scores.argsort()[::-1]
    dets = dets[descending].reshape(-1, 2)
    scores = scores[descending]
    return dets, scores


# def nms_with_cls(proposals, threshold=0.0, top_k=np.inf):
#     """NMS for temporal proposals.
#
#     Args:
#         proposals (np.ndarray): Proposals generated by network.
#         threshold (float): High threshold for soft nms.
#         top_k (int): Top k values to be considered.
#
#     Returns:
#         np.ndarray: The updated proposals.
#     """
#     if proposals.size == 0:
#         return proposals
#     proposals = proposals[proposals[:, -1].argsort()[::-1]]
#     tclass = proposals[:, 0]
#     tstart = proposals[:, 1]
#     tend = proposals[:, 2]
#     tscore = proposals[:, 3]
#     rclass = []
#     rstart = []
#     rend = []
#     rscore = []
#
#
#     while max(tscore, default=0) > 0 and len(rscore) < top_k:
#         max_index = np.argmax(tscore)
#         max_score = tscore[max_index]
#         max_start = tstart[max_index]
#         max_end = tend[max_index]
#         max_cls = tclass[max_index]
#
#         rstart.append(max_start)
#         rend.append(max_end)
#         rscore.append(max_score)
#         rclass.append(max_cls)
#
#         tstart = np.delete(tstart, max_index)
#         tend = np.delete(tend, max_index)
#         tscore = np.delete(tscore, max_index)
#         tclass = np.delete(tclass, max_index)
#
#         iou_list = temporal_iou(max_start, max_end, tstart, tend)
#         tscore[iou_list > threshold] = 0
#
#     rstart = np.array(rstart).reshape(-1, 1)
#     rend = np.array(rend).reshape(-1, 1)
#     rscore = np.array(rscore).reshape(-1, 1)
#     rclass = np.array(rclass).reshape(-1, 1)
#     remained = np.concatenate((rclass, rstart, rend, rscore), axis=1)
#     return remained
def nms1d(dets, scores, iou_thr=0.0, top_k=np.inf, return_idx=False, backend='numpy'):
    """NMS for temporal proposals.

    Args:
        dets (Tensor): Proposals generated by network.
        iou_thr (Tensor): High threshold for soft nms.
        top_k (Tensor): Top k values to be considered.

    Returns:
        Tensor: The updated proposals.
    """
    on_tensor = True if backend == 'torch' else False
    if dets.size == 0:
        return (dets, scores) if not return_idx else (dets, scores, np.empty([]))
    scores_ = scores.clone() if on_tensor else scores.copy()
    keep = []
    while scores_.max() > 0 and len(keep) < top_k:
        max_index = scores_.argmax(dim=0) if on_tensor else scores_.argmax(axis=0)

        keep.append(max_index)
        scores_[max_index] = 0

        remain = scores_.nonzero(as_tuple=True) if on_tensor else scores_.nonzero()

        ious = one_vs_n_iou(dets[max_index], dets[remain], backend=backend)
        scores_[remain[0][ious > iou_thr]] = 0

    keep = torch.stack(keep) if on_tensor else np.stack(keep)
    dets = dets[keep, :]
    scores = scores[keep]
    if not return_idx:
        return dets, scores
    return dets, scores, keep


def one_vs_n_iou(one_box, n_boxes, backend='numpy'):
    """Compute IoU score between a box and other n boxes.

    (1D)
    """
    one_len = one_box[1] - one_box[0]
    n_len = n_boxes[:, 1] - n_boxes[:, 0]
    if backend == 'torch':
        inter_left = torch.maximum(one_box[0], n_boxes[:, 0])
        inter_right = torch.minimum(one_box[1], n_boxes[:, 1])
        inter_len = torch.clamp(inter_right - inter_left, min=0)
        union_len = one_len + n_len - inter_len
        jaccard = torch.divide(inter_len, union_len)
    else:
        inter_left = np.maximum(one_box[0], n_boxes[:, 0])
        inter_right = np.minimum(one_box[1], n_boxes[:, 1])
        inter_len = (inter_right - inter_left).clip(min=0)
        union_len = one_len + n_len - inter_len
        jaccard = np.divide(inter_len, union_len)
    return jaccard


def plot_detection(video_prediction, gt, ads):
    from matplotlib import pyplot as plt
    import numpy as np
    plt.figure(figsize=(15, 5))
    plt.plot(video_prediction, '-')
    plt.vlines(gt[:, 0], 0, 100, colors='r', linestyles='solid', label='ground truth')
    plt.vlines(gt[:, 1], 0, 100, colors='r', linestyles='solid', label='ground truth')
    plt.vlines(ads[:, 0], 0, 100, colors='k', linestyles='dashed', label='ground truth')
    plt.vlines(ads[:, 1], 0, 100, colors='k', linestyles='dashed', label='ground truth')
    plt.yticks(np.arange(0, 100, 20.0))
    plt.xlabel('Frame Index')
    plt.ylabel('Completeness')
    plt.grid()
    plt.show()


def plot_prediction(video_prediction):
    from matplotlib import pyplot as plt
    import numpy as np
    plt.figure(figsize=(15, 5))
    plt.plot(video_prediction, '-')
    plt.yticks(np.arange(0, 100, 20.0))
    plt.xlabel('Frame Index')
    plt.ylabel('Completeness')
    plt.grid()
    plt.show()
